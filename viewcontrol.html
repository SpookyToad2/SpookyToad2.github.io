<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Viewcontrol System â€” Developer Guide</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet" />
  <style>
    :root {
      --bg:        #0d1117;
      --surface:   #161b22;
      --border:    #30363d;
      --accent:    #58a6ff;
      --accent2:   #f78166;
      --accent3:   #3fb950;
      --accent4:   #d2a8ff;
      --text:      #e6edf3;
      --muted:     #8b949e;
      --tag-a-bg:  #1d3557;
      --tag-b-bg:  #2d1b4e;
      --tag-note:  #1c2a1c;
      --warn-bg:   #2a1a00;
      --warn-bd:   #d29922;
      --note-bd:   #3fb950;
    }

    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: 'Inter', sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
    }

    /* â”€â”€ STICKY HEADER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #header {
      position: sticky;
      top: 0;
      z-index: 100;
      background: rgba(13,17,23,0.92);
      backdrop-filter: blur(12px);
      border-bottom: 1px solid var(--border);
      padding: 14px 28px;
      display: flex;
      align-items: center;
      gap: 16px;
      flex-wrap: wrap;
    }

    #header h1 {
      font-size: 1rem;
      font-weight: 700;
      color: var(--accent);
      white-space: nowrap;
    }

    #header .subtitle {
      font-size: 0.75rem;
      color: var(--muted);
    }

    /* Function quick-select bar */
    #fn-bar {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      margin-left: auto;
    }

    #fn-bar a {
      text-decoration: none;
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.7rem;
      font-weight: 600;
      padding: 3px 9px;
      border-radius: 999px;
      border: 1px solid transparent;
      transition: background 0.15s, border-color 0.15s;
    }
    #fn-bar a.tag-a {
      background: var(--tag-a-bg);
      color: var(--accent);
      border-color: var(--accent);
    }
    #fn-bar a.tag-a:hover { background: var(--accent); color: #0d1117; }
    #fn-bar a.tag-b {
      background: var(--tag-b-bg);
      color: var(--accent4);
      border-color: var(--accent4);
    }
    #fn-bar a.tag-b:hover { background: var(--accent4); color: #0d1117; }

    /* â”€â”€ INFO RIBBON (shown at top) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #ribbon {
      background: linear-gradient(135deg, #1d3557 0%, #2d1b4e 100%);
      border-bottom: 1px solid var(--border);
      padding: 18px 32px;
    }

    #ribbon h2 {
      font-size: 0.9rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
      margin-bottom: 10px;
    }

    .quick-ref {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 10px;
    }

    .qr-card {
      background: rgba(0,0,0,0.3);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px 14px;
    }

    .qr-card .label {
      font-size: 0.7rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--muted);
      margin-bottom: 6px;
    }

    .qr-card code {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.78rem;
      display: block;
      color: var(--accent3);
      line-height: 1.7;
    }

    .qr-card code span { color: var(--accent); }
    .qr-card .desc   { font-size: 0.72rem; color: var(--muted); margin-top: 5px; }

    /* â”€â”€ MAIN LAYOUT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #main {
      max-width: 1120px;
      margin: 0 auto;
      padding: 36px 28px 80px;
      display: flex;
      flex-direction: column;
      gap: 56px;
    }

    /* â”€â”€ SECTION HEADINGS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .section-heading {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 20px;
      padding-bottom: 10px;
      border-bottom: 1px solid var(--border);
    }

    .section-heading .badge {
      font-size: 0.68rem;
      font-weight: 700;
      letter-spacing: 0.08em;
      padding: 3px 9px;
      border-radius: 4px;
      text-transform: uppercase;
    }

    .badge-a  { background: var(--tag-a-bg); color: var(--accent); border: 1px solid var(--accent); }
    .badge-b  { background: var(--tag-b-bg); color: var(--accent4); border: 1px solid var(--accent4); }
    .badge-ev { background: #1a2a1a; color: var(--accent3); border: 1px solid var(--accent3); }
    .badge-ll { background: #222; color: var(--muted); border: 1px solid var(--border); }

    .section-heading h2 {
      font-size: 1.25rem;
      font-weight: 700;
      color: var(--text);
    }

    .section-desc {
      font-size: 0.86rem;
      color: var(--muted);
      line-height: 1.6;
      margin-bottom: 20px;
      max-width: 820px;
    }

    /* â”€â”€ FUNCTION CARDS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .fn-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(480px, 1fr));
      gap: 16px;
    }

    .fn-card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 20px 22px;
      transition: border-color 0.2s, box-shadow 0.2s;
      scroll-margin-top: 80px;
    }

    .fn-card:hover {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(88,166,255,0.15);
    }

    .fn-card.ll {
      opacity: 0.8;
      border-style: dashed;
    }
    .fn-card.ll:hover { border-color: var(--muted); box-shadow: none; }

    .fn-sig {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--accent);
      word-break: break-all;
      margin-bottom: 12px;
      line-height: 1.5;
    }
    .fn-sig .fn-name { color: var(--accent3); }
    .fn-sig .fn-param { color: var(--accent4); }
    .fn-sig .fn-default { color: var(--muted); }

    .fn-purpose, .fn-when, .fn-note, .fn-params {
      font-size: 0.82rem;
      line-height: 1.65;
      margin-bottom: 10px;
    }

    .label-inline {
      font-size: 0.68rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.07em;
      padding: 2px 6px;
      border-radius: 4px;
      margin-right: 6px;
      vertical-align: middle;
    }

    .lbl-purpose { background: #1d2d44; color: var(--accent); }
    .lbl-when    { background: #1a2a1a; color: var(--accent3); }
    .lbl-note    { background: var(--warn-bg); color: var(--warn-bd); border: 1px solid var(--warn-bd); }
    .lbl-params  { background: var(--tag-b-bg); color: var(--accent4); }

    .fn-purpose { color: var(--text); }
    .fn-when    { color: #b2dab4; }
    .fn-note    { background: var(--warn-bg); border: 1px solid var(--warn-bd); border-radius: 6px; padding: 8px 12px; color: #f0c060; }
    .fn-note code, .fn-purpose code, .fn-when code {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.8em;
      background: rgba(255,255,255,0.07);
      padding: 1px 5px;
      border-radius: 3px;
    }

    .param-table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 4px;
    }

    .param-table th {
      text-align: left;
      font-size: 0.68rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--muted);
      padding: 4px 8px;
      border-bottom: 1px solid var(--border);
    }

    .param-table td {
      font-size: 0.78rem;
      padding: 5px 8px;
      border-bottom: 1px solid rgba(48,54,61,0.5);
      vertical-align: top;
    }

    .param-table td:first-child {
      font-family: 'JetBrains Mono', monospace;
      color: var(--accent4);
      white-space: nowrap;
    }

    .param-table td:nth-child(2) {
      color: var(--muted);
      font-size: 0.72rem;
    }

    .param-table td:nth-child(3) { color: var(--text); }

    /* â”€â”€ ALERT BOXES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .alert {
      border-radius: 8px;
      padding: 14px 18px;
      font-size: 0.83rem;
      line-height: 1.6;
      margin-top: 24px;
    }
    .alert.info {
      background: #0d2035;
      border: 1px solid var(--accent);
      color: #b0d4f8;
    }
    .alert.warn {
      background: var(--warn-bg);
      border: 1px solid var(--warn-bd);
      color: #f0c060;
    }
    .alert strong { font-weight: 700; }
    .alert code {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.82em;
      background: rgba(255,255,255,0.07);
      padding: 1px 5px;
      border-radius: 3px;
    }

    /* â”€â”€ EVENT TABLE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .event-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.83rem;
    }
    .event-table th {
      text-align: left;
      font-size: 0.7rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.07em;
      color: var(--muted);
      padding: 8px 14px;
      border-bottom: 1px solid var(--border);
    }
    .event-table td {
      padding: 9px 14px;
      border-bottom: 1px solid rgba(48,54,61,0.5);
      vertical-align: top;
    }
    .event-table td:first-child {
      font-family: 'JetBrains Mono', monospace;
      color: var(--accent3);
    }
    .event-table td:nth-child(2) { color: var(--text); }

    /* â”€â”€ FOOTER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    footer {
      text-align: center;
      font-size: 0.72rem;
      color: var(--muted);
      padding: 28px;
      border-top: 1px solid var(--border);
      margin-top: 60px;
    }
  </style>
</head>
<body>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     STICKY HEADER â€” always at the top of the screen
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<header id="header">
  <div>
    <h1>ğŸ“· Viewcontrol System</h1>
    <div class="subtitle">viewcontrol_controller.nut Â· TF2 VScript Â· SpookyToad</div>
  </div>
  <nav id="fn-bar" aria-label="Quick jump to function">
    <a class="tag-a" href="#fn-SpawnAndEnableAll">SpawnAndEnableAll</a>
    <a class="tag-a" href="#fn-SpawnAndEnable">SpawnAndEnable</a>
    <a class="tag-a" href="#fn-DisableAndDestroy">DisableAndDestroy</a>
    <a class="tag-b" href="#fn-SpawnAndEnablePerPlayer">SpawnAndEnablePerPlayer</a>
    <a class="tag-b" href="#fn-DisableAndDestroyPerPlayer">DisableAndDestroyPerPlayer</a>
  </nav>
</header>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     TOP RIBBON â€” quick reference (always visible on load)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div id="ribbon">
  <h2>âš¡ Quick Reference â€” Which function do I call?</h2>
  <div class="quick-ref">

    <div class="qr-card">
      <div class="label">ğŸŒ Camera for Everyone</div>
      <code>
        <span>SpawnAndEnableAll()</span>     &nbsp;â† enable<br>
        <span>DisableAndDestroy()</span>      &nbsp;â† disable
      </code>
      <div class="desc">One camera, every player sees it simultaneously (e.g. cinematic intro, boss spawn).</div>
    </div>

    <div class="qr-card">
      <div class="label">ğŸ‘¤ Camera for ONE Player</div>
      <code>
        <span>SpawnAndEnable(player)</span>   â† enable<br>
        <span>DisableAndDestroy()</span>       â† disable
      </code>
      <div class="desc">Shared camera shown to only one player (e.g. player-triggered cutscene).</div>
    </div>

    <div class="qr-card">
      <div class="label">ğŸ¬ Cinematic / Path Camera â€” Per-Player</div>
      <code>
        <span>SpawnAndEnablePerPlayer(</span><br>
        &nbsp; hTarget, hMoveTo,<br>
        &nbsp; speed, accel, decel<br>
        <span>)</span>                        â† enable<br>
        <span>DisableAndDestroyPerPlayer()</span> â† disable
      </code>
      <div class="desc">Each player gets their <strong>own</strong> camera that can follow a <code>path_corner</code> entity â€” perfect for personal intros or guided cinematic sequences unique per player.</div>
    </div>

    <div class="qr-card">
      <div class="label">ğŸ”„ Automatic Cleanup Events</div>
      <code>
        teamplay_round_start<br>
        teamplay_round_win<br>
        scorestats_accumulated_update<br>
        recalculate_holidays
      </code>
      <div class="desc">All cameras are destroyed automatically on these events. No manual cleanup needed at round end.</div>
    </div>

  </div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     MAIN CONTENT
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<main id="main">

  <!-- â”€â”€ OVERVIEW â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
  <section>
    <div class="section-heading">
      <h2>Overview</h2>
    </div>
    <p class="section-desc">
      This script manages <code>point_viewcontrol</code> camera entities in TF2 VScript.
      It exposes two independent camera systems that can run side by side.
      Both systems automatically <strong>freeze players</strong> (FL_ATCONTROLS flag),
      make them <strong>invulnerable</strong>, and <strong>restore all state</strong>
      (damage, taunt-cam) when the camera is released.
    </p>
    <div class="alert info">
      <strong>ğŸ’¡ How to set up:</strong>
      Attach <code>viewcontrol_controller.nut</code> to any entity
      (e.g. <code>info_target</code>, <code>info_teleport_destination</code>).
      The entity's <strong>origin and angles</strong> become the camera's spawn position and facing direction.
      Then call one of the <code>SpawnAndEnable*</code> functions to activate.
    </div>
  </section>

  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       SYSTEM A â€” SHARED CAMERA
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <section>
    <div class="section-heading">
      <span class="badge badge-a">System A</span>
      <h2>Shared Camera â€” One Camera for Everyone</h2>
    </div>
    <p class="section-desc">
      A single <code>point_viewcontrol</code> entity is spawned and shown to all (or one) players.
      Great for cinematic cutscenes, boss introductions, or event sequences where
      every player watches the same view.
    </p>

    <div class="fn-grid">

      <!-- SpawnAndEnableAll -->
      <div class="fn-card" id="fn-SpawnAndEnableAll">
        <div class="fn-sig">
          <span class="fn-name">SpawnAndEnableAll</span>(<span class="fn-param">hParent</span> <span class="fn-default">= null</span>)
        </div>
        <p class="fn-purpose">
          <span class="label-inline lbl-purpose">What</span>
          The <strong>main "turn on the camera for everyone"</strong> function.
          Spawns a single <code>point_viewcontrol</code> at this entity's origin/angles,
          then immediately switches <strong>all connected players</strong> to it.
        </p>
        <p class="fn-when">
          <span class="label-inline lbl-when">When</span>
          Use for any event where every player should watch the same camera simultaneously â€”
          e.g. a cinematic intro sequence, a boss-spawn cutscene, or an end-of-round replay.
        </p>
        <div class="fn-params">
          <span class="label-inline lbl-params">Params</span>
          <table class="param-table">
            <thead><tr><th>Name</th><th>Default</th><th>Description</th></tr></thead>
            <tbody>
              <tr>
                <td>hParent</td><td>null</td>
                <td>Optional entity handle to parent the camera to. If the parent moves, the camera follows. Pass <code>null</code> for a static camera.</td>
              </tr>
            </tbody>
          </table>
        </div>
        <p class="fn-note">
          <span class="label-inline lbl-note">Note</span>
          If a camera already exists it is <strong>destroyed first</strong>, so calling this multiple times is safe.
          Internally calls <code>SpawnCamera()</code> â†’ <code>EnableCameraAll()</code>.
        </p>
      </div>

      <!-- SpawnAndEnable -->
      <div class="fn-card" id="fn-SpawnAndEnable">
        <div class="fn-sig">
          <span class="fn-name">SpawnAndEnable</span>(<span class="fn-param">hPlayer</span>, <span class="fn-param">hParent</span> <span class="fn-default">= null</span>)
        </div>
        <p class="fn-purpose">
          <span class="label-inline lbl-purpose">What</span>
          Same as <code>SpawnAndEnableAll</code>, but only enables the camera for <strong>one specific player</strong>.
          Spawns the shared camera and routes it to <code>hPlayer</code> only.
        </p>
        <p class="fn-when">
          <span class="label-inline lbl-when">When</span>
          Use when only one player triggered the event and only they should see the cutscene,
          e.g. a player-specific intro or a triggered sequence.
        </p>
        <div class="fn-params">
          <span class="label-inline lbl-params">Params</span>
          <table class="param-table">
            <thead><tr><th>Name</th><th>Default</th><th>Description</th></tr></thead>
            <tbody>
              <tr><td>hPlayer</td><td>â€”</td><td>Handle of the player to show the camera to.</td></tr>
              <tr><td>hParent</td><td>null</td><td>Optional parent entity (same as <code>SpawnAndEnableAll</code>).</td></tr>
            </tbody>
          </table>
        </div>
      </div>

      <!-- DisableAndDestroy -->
      <div class="fn-card" id="fn-DisableAndDestroy">
        <div class="fn-sig">
          <span class="fn-name">DisableAndDestroy</span>()
        </div>
        <p class="fn-purpose">
          <span class="label-inline lbl-purpose">What</span>
          Shuts down the shared camera. Releases <strong>all players</strong> from the camera view,
          restores their saved <code>m_takedamage</code> and taunt-cam state,
          then <strong>kills</strong> the <code>point_viewcontrol</code> entity.
        </p>
        <p class="fn-when">
          <span class="label-inline lbl-when">When</span>
          Call this when the cutscene or event is over and players should regain control.
          Also called <strong>automatically</strong> on round start/end events â€” so you only
          need to call it if you want to end the camera early.
        </p>
        <p class="fn-note">
          <span class="label-inline lbl-note">Note</span>
          Safe to call even if no camera exists (it checks validity first).
        </p>
      </div>

    </div>

    <!-- Low-level shared -->
    <h3 style="margin-top:28px; margin-bottom:12px; font-size:0.85rem; color:var(--muted); text-transform:uppercase; letter-spacing:0.08em;">
      Lower-level shared camera functions <span style="font-weight:400;">(usually not called directly)</span>
    </h3>
    <div class="fn-grid">

      <div class="fn-card ll">
        <div class="fn-sig"><span class="fn-name">SpawnCamera</span>(<span class="fn-param">hParent</span> <span class="fn-default">= null</span>)</div>
        <p class="fn-purpose">
          <span class="label-inline lbl-purpose">What</span>
          Only <strong>spawns</strong> the <code>point_viewcontrol</code> â€” does NOT enable it for any player.
          Stores the handle in <code>hCamera</code>.
        </p>
        <p class="fn-when">
          <span class="label-inline lbl-when">When</span>
          Useful if you want to pre-spawn the camera and enable it for players one by one later
          with <code>EnableCamera(player)</code>.
        </p>
      </div>

      <div class="fn-card ll">
        <div class="fn-sig"><span class="fn-name">EnableCamera</span>(<span class="fn-param">player</span>)</div>
        <p class="fn-purpose">
          <span class="label-inline lbl-purpose">What</span>
          Switches a single player to the already-spawned shared camera.
          Saves their <code>m_takedamage</code> and <code>ForceTauntCam</code>, freezes them,
          makes them invulnerable, sets first-person mode, and sends the <code>Enable</code> input.
        </p>
        <p class="fn-when">
          <span class="label-inline lbl-when">When</span>
          After <code>SpawnCamera()</code>, to enable per-player. Also handy to add a late-joining
          player to an existing live camera.
        </p>
      </div>

      <div class="fn-card ll">
        <div class="fn-sig"><span class="fn-name">DisableCamera</span>(<span class="fn-param">player</span>)</div>
        <p class="fn-purpose">
          <span class="label-inline lbl-purpose">What</span>
          Releases a single player from the shared camera. Un-freezes them, re-enables local model draw,
          and restores their saved damage/taunt-cam values.
        </p>
        <p class="fn-when">
          <span class="label-inline lbl-when">When</span>
          When one specific player should leave the camera view while others remain watching.
        </p>
        <p class="fn-note">
          <span class="label-inline lbl-note">Note</span>
          Safe even if no saved state exists â€” has fallback defaults.
          Also removes the <code>no_attack</code> attribute as a robustness measure.
        </p>
      </div>

      <div class="fn-card ll">
        <div class="fn-sig"><span class="fn-name">EnableCameraAll</span>()</div>
        <p class="fn-purpose">
          <span class="label-inline lbl-purpose">What</span>
          Calls <code>EnableCamera()</code> on every connected player.
        </p>
        <p class="fn-when">
          <span class="label-inline lbl-when">When</span>
          Internally used by <code>SpawnAndEnableAll()</code>. Call manually if you pre-spawned
          via <code>SpawnCamera()</code> and now want to enable for everyone.
        </p>
      </div>

      <div class="fn-card ll">
        <div class="fn-sig"><span class="fn-name">DisableCameraAll</span>()</div>
        <p class="fn-purpose">
          <span class="label-inline lbl-purpose">What</span>
          Calls <code>DisableCamera()</code> on every connected player.
        </p>
        <p class="fn-when">
          <span class="label-inline lbl-when">When</span>
          Internally used by <code>DisableAndDestroy()</code>.
        </p>
      </div>

      <div class="fn-card ll">
        <div class="fn-sig"><span class="fn-name">DestroyCamera</span>()</div>
        <p class="fn-purpose">
          <span class="label-inline lbl-purpose">What</span>
          Sends <code>Disable</code> to the camera then calls <code>.Kill()</code> on it.
          Nullifies <code>hCamera</code>.
        </p>
        <p class="fn-when">
          <span class="label-inline lbl-when">When</span>
          Called automatically by <code>DisableAndDestroy()</code>. Call directly only if you
          want to destroy the entity without restoring player states.
        </p>
      </div>

    </div>
  </section>

  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       SYSTEM B â€” PER-PLAYER CAMERA
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <section>
    <div class="section-heading">
      <span class="badge badge-b">System B</span>
      <h2>Per-Player Cameras â€” Unique Camera per Player</h2>
    </div>
    <p class="section-desc">
      A separate <code>point_viewcontrol</code> entity is spawned for <strong>each connected player</strong>
      individually. This enables each player to see a different camera view at the same time.
      Cameras in this system support a <strong>lookat target</strong> and a <strong>move-to destination</strong>
      so they can follow a <code>path_corner</code> entity â€” making them ideal for
      <em>personal cinematic sequences</em> or guided camera paths unique to each player.
    </p>
    <div class="alert warn">
      <strong>ğŸ¬ Cinematic / path_corner support:</strong>
      The <code>SpawnAndEnablePerPlayer()</code> family of functions is designed to create
      "cinematic" cameras that can follow a <code>path_corner</code> entity via the
      <code>moveto</code> property. Pass the <code>path_corner</code> entity handle or
      targetname as <code>hMoveTo</code> to guide the camera along the path.
      Use <code>hTarget</code> to make the camera look at a specific entity while it moves.
    </div>

    <div class="fn-grid" style="margin-top:20px;">

      <!-- SpawnAndEnablePerPlayer -->
      <div class="fn-card" id="fn-SpawnAndEnablePerPlayer">
        <div class="fn-sig">
          <span class="fn-name">SpawnAndEnablePerPlayer</span>(<br>
          &nbsp;&nbsp;<span class="fn-param">hTarget</span> <span class="fn-default">= null</span>,
          <span class="fn-param">hMoveTo</span> <span class="fn-default">= null</span>,<br>
          &nbsp;&nbsp;<span class="fn-param">flSpeed</span> <span class="fn-default">= 100</span>,
          <span class="fn-param">flAccel</span> <span class="fn-default">= 1500</span>,
          <span class="fn-param">flDecel</span> <span class="fn-default">= 1500</span>)
        </div>
        <p class="fn-purpose">
          <span class="label-inline lbl-purpose">What</span>
          The <strong>main "give each player their own camera"</strong> function.
          Cleans up any old per-player cameras, then spawns a dedicated
          <code>point_viewcontrol</code> for each connected player.
          Each camera can have a lookat target and a move-to destination.
        </p>
        <p class="fn-when">
          <span class="label-inline lbl-when">When</span>
          Use when every player needs their own unique camera view simultaneously â€”
          e.g. a per-player spawn camera, a personal cinematic intro,
          or a camera guided along a <code>path_corner</code> path to each player's position.
        </p>
        <div class="fn-params">
          <span class="label-inline lbl-params">Params</span>
          <table class="param-table">
            <thead><tr><th>Name</th><th>Default</th><th>Description</th></tr></thead>
            <tbody>
              <tr>
                <td>hTarget</td><td>null</td>
                <td>Entity handle <em>or</em> targetname string of the entity the camera should <strong>look at</strong>. Pass <code>null</code> to ignore.</td>
              </tr>
              <tr>
                <td>hMoveTo</td><td>null</td>
                <td>Entity handle <em>or</em> targetname string of the entity the camera should <strong>move toward</strong> after spawning (e.g. a <code>path_corner</code>). Pass <code>null</code> for a static camera.</td>
              </tr>
              <tr>
                <td>flSpeed</td><td>100</td>
                <td>Camera movement speed (units/sec).</td>
              </tr>
              <tr>
                <td>flAccel</td><td>1500</td>
                <td>How quickly the camera accelerates to <code>flSpeed</code>.</td>
              </tr>
              <tr>
                <td>flDecel</td><td>1500</td>
                <td>How quickly the camera decelerates when stopping.</td>
              </tr>
            </tbody>
          </table>
        </div>
        <p class="fn-note">
          <span class="label-inline lbl-note">Note</span>
          Camera spawns at the script entity's origin with spawnflags <code>13</code>:
          Bit 0 (Start at player pos) + Bit 2 (Freeze player â€” <strong>required or the camera won't work</strong>) + Bit 3 (Infinite hold time).
        </p>
      </div>

      <!-- DisableAndDestroyPerPlayer -->
      <div class="fn-card" id="fn-DisableAndDestroyPerPlayer">
        <div class="fn-sig">
          <span class="fn-name">DisableAndDestroyPerPlayer</span>()
        </div>
        <p class="fn-purpose">
          <span class="label-inline lbl-purpose">What</span>
          Disables and <strong>destroys all per-player camera entities</strong>.
          Restores every affected player's state (unfreeze, re-enable damage).
          Clears the internal camera tracking table.
        </p>
        <p class="fn-when">
          <span class="label-inline lbl-when">When</span>
          When the per-player scene is finished. Also called <strong>automatically</strong>
          on all round start/end events â€” call it manually only to end the cameras early.
        </p>
      </div>

    </div>

    <!-- Low-level per-player -->
    <h3 style="margin-top:28px; margin-bottom:12px; font-size:0.85rem; color:var(--muted); text-transform:uppercase; letter-spacing:0.08em;">
      Lower-level per-player functions <span style="font-weight:400;">(normally not called directly)</span>
    </h3>
    <div class="fn-grid">

      <div class="fn-card ll">
        <div class="fn-sig">
          <span class="fn-name">SpawnViewControlForPlayer</span>(<span class="fn-param">player</span>, <span class="fn-param">hTarget</span>, <span class="fn-param">hMoveTo</span>, <span class="fn-param">flSpeed</span>, <span class="fn-param">flAccel</span>, <span class="fn-param">flDecel</span>)
        </div>
        <p class="fn-purpose">
          <span class="label-inline lbl-purpose">What</span>
          Spawns and enables a camera for <strong>one specific player</strong>.
          Generates a unique targetname (<code>scriptentityname_viewcontrol_&lt;entindex&gt;</code>).
          Stores the camera handle in <code>hPlayerCameras[entindex]</code>.
        </p>
        <p class="fn-when">
          <span class="label-inline lbl-when">When</span>
          Used internally by <code>SpawnAndEnablePerPlayer()</code>. Call directly only if you
          need to create a camera for a single new player without touching everyone else.
        </p>
      </div>

      <div class="fn-card ll">
        <div class="fn-sig">
          <span class="fn-name">EnablePerPlayerCamera</span>(<span class="fn-param">player</span>, <span class="fn-param">camera</span>)
        </div>
        <p class="fn-purpose">
          <span class="label-inline lbl-purpose">What</span>
          Applies per-player constraints (freeze, invulnerability, first-person) and sends
          the <code>Enable</code> input to the given camera with the player as activator.
          Uses a separate saved-state key (<code>viewcontrol_pp_saved_state</code>) so it
          does not conflict with the shared camera system.
        </p>
        <p class="fn-when">
          <span class="label-inline lbl-when">When</span>
          Called automatically by <code>SpawnViewControlForPlayer()</code>. You can call it
          manually if you have a camera handle and want to re-enable it for a player.
        </p>
      </div>

      <div class="fn-card ll">
        <div class="fn-sig">
          <span class="fn-name">DisablePerPlayerCamera</span>(<span class="fn-param">player</span>, <span class="fn-param">camera</span>)
        </div>
        <p class="fn-purpose">
          <span class="label-inline lbl-purpose">What</span>
          Releases a single player from their per-player camera. Restores their saved state,
          removes freeze flag, re-enables local draw, and removes the <code>no_attack</code> attribute.
        </p>
        <p class="fn-when">
          <span class="label-inline lbl-when">When</span>
          Called by <code>DisableAndDestroyPerPlayer()</code> for each player. Useful to release
          one player's camera early without touching others.
        </p>
      </div>

    </div>
  </section>

  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       EVENT CLEANUP
  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <section>
    <div class="section-heading">
      <span class="badge badge-ev">Auto</span>
      <h2>Automatic Event Cleanup</h2>
    </div>
    <p class="section-desc">
      Both systems automatically destroy all cameras on the following game events.
      <strong>You do not need to handle round-end cleanup yourself.</strong>
    </p>
    <table class="event-table">
      <thead>
        <tr><th>Event</th><th>When it fires</th></tr>
      </thead>
      <tbody>
        <tr>
          <td>teamplay_round_start</td>
          <td>A new round begins. Cameras are destroyed so players enter the round normally.</td>
        </tr>
        <tr>
          <td>teamplay_round_win</td>
          <td>A team wins the round. Cameras released before win state fully resolves.</td>
        </tr>
        <tr>
          <td>scorestats_accumulated_update</td>
          <td>End-of-round stats screen. Cameras destroyed and the event table is also cleaned up from the root scope.</td>
        </tr>
        <tr>
          <td>recalculate_holidays</td>
          <td>Fires at round end. Script checks round state â€” only cleans if state is <code>8</code> (Round End) or <code>5</code> (Team Win / Arena).</td>
        </tr>
      </tbody>
    </table>
    <div class="alert info" style="margin-top:14px;">
      <strong>CollectEventsInScope(events)</strong> â€” Internal utility that binds these callbacks
      and self-cleans the event table from the root scope after use.
      <strong>Do not call this manually.</strong> It is invoked automatically when the script loads.
    </div>
  </section>

</main>

<footer>
  viewcontrol_controller.nut Â· Based on Easy PVC Control by worMatty Â· Refactored by SpookyToad
</footer>

</body>
</html>
